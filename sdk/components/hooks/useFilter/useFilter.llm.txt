# useFilter Hook - LLM Documentation

## Overview

The `useFilter` hook is a React hook for managing filter conditions with:
- Type-safe filter condition management
- Support for simple conditions and nested logical groups
- API payload generation (id fields stripped automatically)
- Integrated with useTable and useKanban hooks

## Import

```typescript
import { useFilter, isCondition, isConditionGroup } from "@ram_28/kf-ai-sdk/filter";
import type {
  UseFilterOptionsType,
  UseFilterReturnType,
  ConditionType,
  ConditionGroupType,
  ConditionGroupOperatorType,
  FilterType,
} from "@ram_28/kf-ai-sdk/filter/types";
```

## Basic Usage

### Standalone Usage

```typescript
const filter = useFilter({
  operator: "And",
});

// Add a condition at root level
const id = filter.addCondition({
  Operator: "GT",
  LHSField: "Price",
  RHSValue: 100,
  RHSType: "Constant",
});

// Add a nested group
const groupId = filter.addConditionGroup("Or");

// Add conditions to the group
filter.addCondition({
  Operator: "EQ",
  LHSField: "Category",
  RHSValue: "Electronics",
}, groupId);
```

### Through useTable

```typescript
const table = useTable<ProductType>({
  source: "BDO_Products",
  columns: [...],
  enableFiltering: true,
});

// Use table.filter for all filter operations
table.filter.addCondition({
  Operator: "EQ",
  LHSField: "Category",
  RHSValue: "Electronics",
  RHSType: "Constant",
});

// Clear all filters
table.filter.clearAllConditions();
```

## Configuration Options

### UseFilterOptionsType

| Property | Type | Required | Default | Description |
|----------|------|----------|---------|-------------|
| `conditions` | `Array<ConditionType \| ConditionGroupType>` | No | `[]` | Filter conditions |
| `operator` | `ConditionGroupOperatorType` | No | `"And"` | Operator for combining conditions |

## Return Value

### UseFilterReturnType

#### State (read-only)
| Property | Type | Description |
|----------|------|-------------|
| `operator` | `ConditionGroupOperatorType` | Current root operator ("And" \| "Or" \| "Not") |
| `items` | `Array<ConditionType \| ConditionGroupType>` | Current filter items (with id populated) |
| `payload` | `FilterType \| undefined` | Ready-to-use API payload (id stripped, undefined if no conditions) |
| `hasConditions` | `boolean` | Whether any conditions exist |

#### Add Operations
| Method | Type | Description |
|--------|------|-------------|
| `addCondition` | `(condition: Omit<ConditionType, "id">, parentId?: string) => string` | Add a leaf condition. If parentId omitted, adds at root level. Returns the id of the created condition. |
| `addConditionGroup` | `(operator: ConditionGroupOperatorType, parentId?: string) => string` | Add a condition group. If parentId omitted, adds at root level. Returns the id of the created group. |

#### Update Operations
| Method | Type | Description |
|--------|------|-------------|
| `updateCondition` | `(id: string, updates: Partial<Omit<ConditionType, "id">>) => void` | Update a leaf condition by id |
| `updateGroupOperator` | `(id: string, operator: ConditionGroupOperatorType) => void` | Update a condition group's operator by id |

#### Remove & Access
| Method | Type | Description |
|--------|------|-------------|
| `removeCondition` | `(id: string) => void` | Remove a condition or group by id |
| `getCondition` | `(id: string) => ConditionType \| ConditionGroupType \| undefined` | Get a condition or group by id |

#### Utility
| Method | Type | Description |
|--------|------|-------------|
| `clearAllConditions` | `() => void` | Clear all conditions |
| `setRootOperator` | `(op: ConditionGroupOperatorType) => void` | Set the root operator for combining conditions |

## Types

### ConditionType (Leaf Condition)

```typescript
interface ConditionType {
  id?: string;                    // Auto-generated unique identifier
  Operator: ConditionOperatorType;
  LHSField: string;               // Field name to filter on
  RHSValue: any;                  // Value to compare against
  RHSType?: FilterRHSTypeType;    // "Constant" | "BDOField" | "AppVariable"
}
```

### ConditionGroupType (Nested Group)

```typescript
interface ConditionGroupType {
  id?: string;                    // Auto-generated unique identifier
  Operator: ConditionGroupOperatorType;  // "And" | "Or" | "Not"
  Condition: Array<ConditionType | ConditionGroupType>;  // Nested items
}
```

### Type Guards

```typescript
// Check if item is a leaf condition
if (isCondition(item)) {
  console.log(item.LHSField, item.Operator, item.RHSValue);
}

// Check if item is a condition group
if (isConditionGroup(item)) {
  console.log(item.Operator, item.Condition.length, "nested items");
}
```

## Filter Operators

### Comparison Operators (ConditionOperatorType)
| Operator | Description | Example |
|----------|-------------|---------|
| `EQ` | Equal | `Price = 100` |
| `NE` | Not Equal | `Status != "Active"` |
| `GT` | Greater Than | `Stock > 0` |
| `GTE` | Greater Than or Equal | `Price >= 50` |
| `LT` | Less Than | `Rating < 3` |
| `LTE` | Less Than or Equal | `Discount <= 20` |

### Range Operators
| Operator | Description | RHS Format |
|----------|-------------|------------|
| `Between` | Between two values | `[min, max]` |
| `NotBetween` | Not between two values | `[min, max]` |

### Set Operators
| Operator | Description | RHS Format |
|----------|-------------|------------|
| `IN` | In array | `[value1, value2, ...]` |
| `NIN` | Not in array | `[value1, value2, ...]` |

### String Operators
| Operator | Description |
|----------|-------------|
| `Contains` | Contains substring |
| `NotContains` | Does not contain substring |

### Null Operators
| Operator | Description | RHS Required |
|----------|-------------|--------------|
| `Empty` | Is empty/null | No |
| `NotEmpty` | Is not empty/null | No |

### Group Operators (ConditionGroupOperatorType)
| Operator | Description |
|----------|-------------|
| `And` | All conditions must match |
| `Or` | Any condition must match |
| `Not` | Negate conditions |

## Usage Examples

### Simple Category Filter

```typescript
const filterByCategory = (category: string) => {
  table.filter.clearAllConditions();
  if (category !== "all") {
    table.filter.addCondition({
      Operator: "EQ",
      LHSField: "Category",
      RHSValue: category,
      RHSType: "Constant",
    });
  }
};
```

### Price Range Filter

```typescript
const handlePriceRange = (min: number, max: number | null) => {
  if (max === null) {
    // Open-ended range: $200 & Above
    table.filter.addCondition({
      Operator: "GTE",
      LHSField: "Price",
      RHSValue: min,
      RHSType: "Constant",
    });
  } else {
    // Closed range: $25 to $50
    table.filter.addCondition({
      Operator: "Between",
      LHSField: "Price",
      RHSValue: [min, max],
      RHSType: "Constant",
    });
  }
};
```

### Complex Nested Filter

```typescript
// Build: (Category = "Electronics") AND (Price > 100 OR OnSale = true)
const buildComplexFilter = () => {
  filter.clearAllConditions();

  // Add root condition
  filter.addCondition({
    Operator: "EQ",
    LHSField: "Category",
    RHSValue: "Electronics",
  });

  // Create nested OR group
  const groupId = filter.addConditionGroup("Or");

  // Add conditions to the group
  filter.addCondition({
    Operator: "GT",
    LHSField: "Price",
    RHSValue: 100,
  }, groupId);

  filter.addCondition({
    Operator: "EQ",
    LHSField: "OnSale",
    RHSValue: true,
  }, groupId);
};
```

### Field-to-Field Comparison (BDOField)

```typescript
// Filter where Quantity exceeds Stock (field vs field)
filter.addCondition({
  Operator: "GT",
  LHSField: "Quantity",
  RHSValue: "Stock",
  RHSType: "BDOField",
});
```

### Toggle Root Operator

```typescript
const toggleFilterLogic = () => {
  const next = filter.operator === "And" ? "Or" : "And";
  filter.setRootOperator(next);
};
```

### Render Filter Tree

```typescript
const renderFilterItem = (item: ConditionType | ConditionGroupType) => {
  if (isCondition(item)) {
    return (
      <div key={item.id}>
        {item.LHSField} {item.Operator} {String(item.RHSValue)}
        <button onClick={() => filter.removeCondition(item.id!)}>Remove</button>
      </div>
    );
  }

  if (isConditionGroup(item)) {
    return (
      <div key={item.id}>
        <span>{item.Operator} Group</span>
        <button onClick={() => filter.addCondition({ Operator: "EQ", LHSField: "Field", RHSValue: "" }, item.id!)}>
          + Condition
        </button>
        <button onClick={() => filter.addConditionGroup("And", item.id!)}>+ Group</button>
        {item.Condition.map((child) => renderFilterItem(child))}
      </div>
    );
  }
};
```

## API Payload Format

The `payload` property automatically strips id fields for API compatibility:

```typescript
// With conditions
{
  Operator: "And",
  Condition: [
    { Operator: "EQ", LHSField: "Category", RHSValue: "Electronics", RHSType: "Constant" },
    {
      Operator: "Or",
      Condition: [
        { Operator: "GT", LHSField: "Price", RHSValue: 100 },
        { Operator: "EQ", LHSField: "OnSale", RHSValue: true }
      ]
    }
  ]
}

// No conditions returns undefined
filter.payload // undefined when items.length === 0
```

## Integration with useTable/useKanban

Filter changes automatically:
- Reset pagination to page 1
- Trigger data refetch
- Update count query

```typescript
const table = useTable<Product>({
  source: "BDO_Products",
  enableFiltering: true,
  initialState: {
    filters: [...],
    filterOperator: "And",
  },
});

// Access filter through table.filter
table.filter.addCondition({...});
table.filter.clearAllConditions();
table.filter.hasConditions;
table.filter.payload;
```

## Filtering Reference & User Fields

Reference and User fields store `{ _id, _name, ... }` objects. Key rules:

- **Default targets `_id`**: Pass string ID as `RHSValue`, backend auto-compares against `_id`
- **Dot notation for nested paths**: Use `"FieldName._name"` in `LHSField` to filter by `_name` or other sub-fields
- **Supported operators**: `EQ`, `NE`, `IN`, `NIN`, `Empty`, `NotEmpty`
- **Contains/NotContains**: Only with dot notation (e.g., `"Vendor._name"`)
- **GT/GTE/LT/LTE/Between**: NOT supported — raises backend error

### Examples

```typescript
// Filter by reference ID
filter.addCondition({
  Operator: "EQ",
  LHSField: "ProductInfo",    // field name, NOT "ProductInfo._id"
  RHSValue: "PROD_001",       // string ID directly
  RHSType: "Constant",
});

// Filter by multiple IDs
filter.addCondition({
  Operator: "IN",
  LHSField: "ProductInfo",
  RHSValue: ["PROD_001", "PROD_002"],
  RHSType: "Constant",
});

// Search by reference name (dot notation)
filter.addCondition({
  Operator: "Contains",
  LHSField: "ProductInfo._name",   // dot notation for nested path
  RHSValue: "Widget",
  RHSType: "Constant",
});

// Filter system user field
filter.addCondition({
  Operator: "EQ",
  LHSField: "_created_by",
  RHSValue: "USR_001",
  RHSType: "Constant",
});
```

### RHSValue Formats

| Format | Example | When to use |
|--------|---------|-------------|
| String ID | `"PROD_001"` | Simplest — use when you have the ID |
| Object | `{ _id: "PROD_001", _name: "Widget" }` | Backend extracts `_id` automatically |
| Array of IDs | `["PROD_001", "PROD_002"]` | With IN/NIN operators |
| Array of objects | `[{ _id: "PROD_001" }]` | With IN/NIN — backend extracts each `_id` |

Prefer passing string IDs directly for simplicity.

## Key Behaviors

1. **Auto-generated IDs**: All conditions get unique IDs via `generateId()`
2. **Payload strips IDs**: The `payload` property excludes id fields for API calls
3. **Recursive operations**: All operations work on nested groups
4. **Type guards**: Use `isCondition()` and `isConditionGroup()` for type-safe operations
5. **Optional parentId**: `addCondition` and `addConditionGroup` add to root when parentId is omitted
